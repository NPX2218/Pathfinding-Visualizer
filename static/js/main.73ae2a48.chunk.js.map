{"version":3,"sources":["PathfindingVisualizer/Node/Node.tsx","algorithms/dijkstra.tsx","algorithms/scatterRandom.tsx","algorithms/generateMaze.tsx","PathfindingVisualizer/PathfindingVisualizer.tsx","App.tsx","index.tsx"],"names":["Node","this","props","row","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","startNodeDistance","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","scatterRandom","i","j","currentNode","currentNodeHTML","document","getElementById","classList","remove","Math","floor","random","console","log","newMaze","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","nodeHTML","add","COLS","ROWS","returnDijkstra","windowWidth","$","window","width","windowHeight","height","innerWidth","innerHeight","rows","columns","on","location","reload","PathfindingVisualizer","setHTMLClass","classNameString","element","split","forEach","clearGrid","state","algorithmTime","innerHTML","changeAnimationSpeed","animationSpeed","changeSpeedIcon","setState","visualizeDijkstra","isAnimationRunning","timeStart","performance","now","nodesInShortestPathOrder","unshift","getNodesInShortestPathOrder","animateDijkstra","timeEnd","string","visualizeAstar","generateScatterRandom","walledMaze","generateRandomMaze","rightMouseIsPressed","leftMouseIsPressed","getInitialGrid","onload","querySelectorAll","addEventListener","e","prevProps","prevState","event","key","getElementsByClassName","oldStartNode","parseInt","oldFinishNode","newGrid","getNewGridWithWallToggled","setTimeout","animateShortestPath","prevNode","undefined","map","rowIdx","nodeIdx","handleMouseRightDown","handleMouseEnter","handleMouseUp","secondaryText","text","title","iconClass","style","display","padding","outline","margin","justifyContent","alignItems","verticalAlign","Navbar","href","data-toggle","onClick","Note","nodeDiv","children","TextArea","fontWeight","currentRow","createNode","slice","newNode","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.73ae2a48.chunk.js","sourcesContent":["///////////////////////////////////////\n// IMPORTING MODULES\n///////////////////////////////////////\n\nimport React, { Component } from 'react';\nimport './Node.css';\n\n///////////////////////////////////////\n// CLASS: NODE\n///////////////////////////////////////\n\ninterface nodeProps{\n    row: number;\n    col: number;\n    isStart: boolean;\n    isFinish: boolean;\n    isWall: boolean;\n    onMouseDown: (row: number, col: number) => void;\n    onMouseUp: (row: number, col: number) => void;\n    onMouseEnter: (row: number, col: number) => void;\n}\n\nexport default class Node extends Component <nodeProps, {}> {\n  render() {\n    const {\n      row, \n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n    } = this.props;\n    const extraClassName = isFinish\n      ? 'node-finish'\n      : isStart\n      ? 'node-start'\n      : isWall\n      ? 'node-wall'\n      : '';\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp(row, col)}\n        ></div>\n    );\n  }\n}\n","\n// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\n\n///////////////////////////////////////\n// FUNCTION: DIKSTRA'S ALGORITHM\n///////////////////////////////////////\n\ninterface nodesObject {\n  col: number,\n  row: number,\n  isVisited: boolean,\n  isWall: boolean,\n  distance: number,\n  previousNode: any,\n  isStart: boolean,\n  isFinish: boolean,\n}\n\nexport function dijkstra(grid : Array<Object>, startNode: nodesObject, finishNode: nodesObject) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    \n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return {visitedNodesInOrder: visitedNodesInOrder, startNodeDistance: null};\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return {visitedNodesInOrder: visitedNodesInOrder, startNodeDistance: closestNode.distance};\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes : Array<nodesObject>) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node : nodesObject, grid : Array<Object>) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node : nodesObject, grid : Array<any>) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid : Array<any>) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode: any) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","const scatterRandom = (grid : Array<any>) => {\r\n    for(let i = 0; i < grid.length; i++) {\r\n        for(let j = 0; j < grid[i].length; j++) {\r\n            const currentNode = grid[i][j];\r\n            const currentNodeHTML = document.getElementById(`node-${i}-${j}`)\r\n            if(currentNodeHTML){\r\n              currentNodeHTML.classList.remove('node-shortest-path', 'node-visited')\r\n              //Change the below number (6) to the probability of a node being a wall\r\n              const wallOrNot = Math.floor((Math.random() * 6) + 1);\r\n              \r\n              if(wallOrNot === 1 && currentNode.isStart !== true && currentNode.isFinish !== true) {\r\n                  currentNode.isWall = true;\r\n              }else if(currentNode.isStart !== true && currentNode.isFinish !== true) {\r\n                  currentNode.isWall = false;\r\n              }\r\n              \r\n              if(currentNode.isVisited === true){\r\n                console.log(document.getElementById(`node-${i}-${j}`))\r\n                currentNode.isVisited = false;\r\n              } \r\n            }\r\n            \r\n        }\r\n    }\r\n    return grid;\r\n}\r\n\r\nexport default scatterRandom;\r\n\r\n/*\r\ndocument.getElementById('algorithm-time').innerHTML = '';\r\n    for(let i  = 0; i < grid.length; i++){\r\n      for(let j = 0; j < grid[0].length; j++){\r\n        grid[i][j].isVisited = false;\r\n        grid[i][j].isWall = false;\r\n        grid[i][j].distance = Infinity;\r\n        grid[i][j].previousNode = null;\r\n        if(grid[i][j].isStart === true){\r\n          document.getElementById(`node-${i}-${j}`).className = 'node node-img-start';\r\n        }else if(grid[i][j].isFinish === true){\r\n          document.getElementById(`node-${i}-${j}`).className = 'node node-img-finish';\r\n        }else if(grid[i][j].isWall === true){\r\n          document.getElementById(`node-${i}-${j}`).className = 'node node-wall';\r\n        }else{\r\n        document.getElementById(`node-${i}-${j}`).className =\r\n          'node';\r\n        }\r\n*/\r\n\r\n/*\r\n\r\n\r\nfor(let i  = 0; i < board.length; i++){\r\n        for(let j = 0; j < board[i].length; j++){\r\n            console.log(board[i][j]);\r\n        }}\r\n  let currentIdX = 1;\r\n  let currentIdY = 0;\r\n  let relevantStatuses = [\"start\", \"target\", \"object\"];\r\n  while (currentIdX > 0 && currentIdY < board.width) {\r\n    let currentId = `${currentIdX}-${currentIdY}`;\r\n    let currentNode = board.nodes[currentId];\r\n    let currentHTMLNode = document.getElementById(currentId);\r\n    if (!relevantStatuses.includes(currentNode.status)) {\r\n      currentNode.status = \"wall\";\r\n      board.wallsToAnimate.push(currentHTMLNode);\r\n    }\r\n    currentIdX--;\r\n    currentIdY++;\r\n  }\r\n  while (currentIdX < board.height - 2 && currentIdY < board.width) {\r\n    let currentId = `${currentIdX}-${currentIdY}`;\r\n    let currentNode = board.nodes[currentId];\r\n    let currentHTMLNode = document.getElementById(currentId);\r\n    if (!relevantStatuses.includes(currentNode.status)) {\r\n      currentNode.status = \"wall\";\r\n      board.wallsToAnimate.push(currentHTMLNode);\r\n    }\r\n    currentIdX++;\r\n    currentIdY++;\r\n  }\r\n  while (currentIdX > 0 && currentIdY < board.width - 1) {\r\n    let currentId = `${currentIdX}-${currentIdY}`;\r\n    let currentNode = board.nodes[currentId];\r\n    let currentHTMLNode = document.getElementById(currentId);\r\n    if (!relevantStatuses.includes(currentNode.status)) {\r\n      currentNode.status = \"wall\";\r\n      board.wallsToAnimate.push(currentHTMLNode);\r\n    }\r\n    currentIdX--;\r\n    currentIdY++;\r\n  }\r\n*/","import { dijkstra } from '../algorithms/dijkstra';\r\nimport { ROWS, COLS, START_NODE_COL, START_NODE_ROW, FINISH_NODE_COL, FINISH_NODE_ROW} from '../PathfindingVisualizer/PathfindingVisualizer';\r\n\r\nconst newMaze = (grid : any) => {\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    console.log(grid)\r\n    for (let i = 0; i < grid.length; i++) {\r\n        for (let j = 0; j < grid[i].length; j++) {\r\n            if (i % 2 === 0 && j % 2 === 0 && grid[i][j].isStart === false && grid[i][j].isFinish === false) {\r\n                grid[i][j].isWall = true;\r\n                const nodeHTML = document.getElementById(`node-${i}-${j}`);\r\n                if(nodeHTML){\r\n                    nodeHTML.classList.add('node-wall');\r\n                }\r\n            }\r\n\r\n            if(grid[i][j].col === 0 || grid[i][j].col === COLS - 1 || grid[i][j].row === 0 || grid[i][j].row === ROWS - 1){\r\n                grid[i][j].isWall = true;\r\n                const nodeHTML = document.getElementById(`node-${i}-${j}`);\r\n                if(nodeHTML){\r\n                    nodeHTML.classList.add('node-wall');\r\n                }\r\n            }\r\n            if (grid[i][j].isWall === false && (i % 2 !== 0 || j % 2 !== 0) && grid[i][j].isStart === false && grid[i][j].isFinish === false) {\r\n                const randomNumber = Math.floor(Math.random() * 5);\r\n                if(randomNumber === 1){\r\n                grid[i][j].isWall = true;\r\n                const nodeHTML = document.getElementById(`node-${i}-${j}`);\r\n                if(nodeHTML){\r\n                    nodeHTML.classList.add('node-wall');\r\n                }\r\n            }\r\n            }\r\n            const returnDijkstra = dijkstra(grid, startNode, finishNode);\r\n            if(returnDijkstra){\r\n                console.log(returnDijkstra.startNodeDistance)\r\n                if(returnDijkstra.startNodeDistance === null){\r\n                    grid[i][j].isWall = false;\r\n                    const nodeHTML = document.getElementById(`node-${i}-${j}`);\r\n                    if(nodeHTML){\r\n                        nodeHTML.classList.remove('node-wall');\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default newMaze;","///////////////////////////////////////\n// IMPORTING MODULES\n///////////////////////////////////////\n\nimport React, { Component } from 'react';\nimport Node from './Node/Node';\nimport { dijkstra, getNodesInShortestPathOrder } from '../algorithms/dijkstra';\nimport './PathfindingVisualizer.css';\nimport scatterRandom from '../algorithms/scatterRandom';\nimport $ from 'jquery';\nimport newMaze from '../algorithms/generateMaze';\n\n\nlet windowWidth = $(window).width() ;\nlet windowHeight = $(window).height();\nif(!windowWidth){windowWidth = window.innerWidth;}\nif(!windowHeight){windowHeight = window.innerHeight;}\n\nlet rows = Math.floor(windowHeight / 50);\nlet columns = Math.floor(windowWidth / 30);\n\nlet ROWS = rows; //16\nlet COLS = columns; //50\nlet START_NODE_COL = Math.floor(COLS / 2.5);\nlet START_NODE_ROW = Math.floor(ROWS / 2);\nlet FINISH_NODE_COL = Math.floor(COLS / 1.5);\nlet FINISH_NODE_ROW = Math.floor(ROWS / 2);\nexport { ROWS, COLS, START_NODE_COL, START_NODE_ROW, FINISH_NODE_COL, FINISH_NODE_ROW };\n\n$(window).on('resize', function(){\n  window.location.reload();\n})\n\n///////////////////////////////////////\n// CLASS: PATHFINDINGVISUALIZER\n///////////////////////////////////////\n\ninterface PathfindingVisualizerProps {\n  grid: Array<Array<Node>>;\n  rightMouseIsPressed: boolean;\n  leftMouseIsPressed: boolean;\n  isAnimationRunning: boolean;\n  animationSpeed: number; \n}\n\nexport default class PathfindingVisualizer extends Component <any, any>{\n  constructor(props: PathfindingVisualizerProps) {\n    super(props);\n    this.state = {\n      grid: [],\n      rightMouseIsPressed: false,\n      leftMouseIsPressed: false,\n      animationSpeed: 10,\n      isAnimationRunning: false,\n    };\n  }\n\n  ///////////////////////////////////////\n  // FUNCTION: PATHFINDINGVISUALIZER ON MOUNT\n  ///////////////////////////////////////\n  componentDidMount() {\n    const grid = getInitialGrid();\n    this.setState({ grid });\n    window.onload = function(){\n      //TODO: Implement remove and add wall with this, and add drag\n      \n      const nodes = document.querySelectorAll('.node')\n      for(let i = 0; i < nodes.length; i++){\n        nodes[i].addEventListener('mouseenter', function(e){\n          nodes[i].classList.add('node-hover');\n        })\n        nodes[i].addEventListener('mouseleave', function(e){\n          nodes[i].classList.remove('node-hover');\n        })\n      }\n        /*\n        nodes[i].addEventListener('mousedown', function(e){\n          if(e.button === 0){\n            console.log(\"left\")\n            console.log(e.target.id)\n          }\n          else if(e.button === 2){\n            console.log(\"right\")\n          }\n          \n        })*/\n      }\n    }\n    \n  ///////////////////////////////////////\n  // FUNCTION: PATHFINDINGVISUALIZER ON STATE RELOAD AND UPDATE\n  ///////////////////////////////////////\n  componentDidUpdate(prevProps : any, prevState : any){\n    const { grid }  = this.state;\n\n    document.addEventListener('keypress', (event) => {\n      if (grid !== prevState.grid) {\n        if (event.key === 's') {\n          const nodeHTML = document.getElementsByClassName('node-hover')[0];\n          if(nodeHTML){\n            const row = nodeHTML.id.split('-')[1];\n            const col = nodeHTML.id.split('-')[2];\n            if(grid[row][col].isStart === false && grid[row][col].isFinish === false){\n              const oldStartNode = document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`);\n              if(oldStartNode){\n                oldStartNode.classList.remove('node-start');\n                grid[START_NODE_ROW][START_NODE_COL].isStart = false;\n              }\n                \n              nodeHTML.classList.add('node-start');\n              nodeHTML.classList.remove('node-hover');\n\n              grid[row][col].isStart = true;\n              grid[row][col].isWall = false\n              \n              START_NODE_ROW = parseInt(row);\n              START_NODE_COL = parseInt(col);    \n              }\n            } \n          }else if (event.key === 'f') {\n            const nodeHTML = document.getElementsByClassName('node-hover')[0];\n            if(nodeHTML){\n              const oldFinishNode = document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`);\n              if(oldFinishNode){\n                oldFinishNode.classList.remove('node-finish');\n                grid[FINISH_NODE_ROW][FINISH_NODE_COL].isFinish = false;\n              }\n                \n              nodeHTML.classList.add('node-finish');\n              nodeHTML.classList.remove('node-hover');\n\n              const row = nodeHTML.id.split('-')[1];\n              const col = nodeHTML.id.split('-')[2];\n\n              grid[row][col].isFinish = true;\n              grid[row][col].isWall = false\n              \n              FINISH_NODE_ROW = parseInt(row);\n              FINISH_NODE_COL = parseInt(col);\n            }\n          }\n      }\n      // Setting the state will reload, and it will make the application laggy\n      // this.setState({ grid: grid });\n    }\n  );\n}\n\n  handleMouseRightDown(row : number, col : number) {\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({grid: newGrid, rightMouseIsPressed: true});\n  }\n\n\n  handleMouseEnter(row : number, col : number) {\n    if (!this.state.rightMouseIsPressed) return;\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({grid: newGrid});\n  }\n\n  handleMouseUp() {\n    this.setState({rightMouseIsPressed: false});\n  }\n\n  setHTMLClass = (node : string, classNameString : string) => {\n    const element = document.getElementById(node);\n    if(element){\n      const classNameArray = classNameString.split(' ');\n      classNameArray.forEach(className => {\n        element.classList.add(className);\n        }); \n    } else {\n      console.log(\"element not found\")\n    }\n  }\n\n  ///////////////////////////////////////\n  // FUNCTION: ANIMATE DIJKSTRA\n  ///////////////////////////////////////\n  animateDijkstra(visitedNodesInOrder: Array<any>, nodesInShortestPathOrder: Array<any>, startNodeDistance : number) {\n      //TODO: Make the speed change as the button is pressed even with animation playing\n      const { animationSpeed } = this.state;\n      for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n        if (i === visitedNodesInOrder.length) {\n          setTimeout(() => {\n            this.animateShortestPath(nodesInShortestPathOrder, startNodeDistance);\n          }, animationSpeed * i);\n          return;\n        }\n        setTimeout(() => {\n          const node = visitedNodesInOrder[i];\n          if(node.isStart === true){\n            this.setHTMLClass(`node-${node.row}-${node.col}`, 'node node-visited node-img-start');\n          }else if(node.isFinish === true){\n            this.setHTMLClass(`node-${node.row}-${node.col}`, 'node node-visited node-img-finish');\n          }else{\n            this.setHTMLClass(`node-${node.row}-${node.col}`, 'node node-visited');\n          }\n        }, animationSpeed * i);\n    }\n\n  }\n\n  ///////////////////////////////////////\n  // FUNCTION: ANIMATE SHORTEST PATH \n  // BETWEEN START AND FINISH NODE\n  ///////////////////////////////////////\n  animateShortestPath(nodesInShortestPathOrder : Array<any>, startNodeDistance : any) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        if(node.isStart === true){\n          this.setHTMLClass(`node-${node.row}-${node.col}`, 'node node-shortest-path-right node-img-start');\n        }else if(node.isFinish === true && startNodeDistance !== null){\n          this.setHTMLClass(`node-${node.row}-${node.col}`, 'node node-shortest-path-right node-img-finish');\n        }else{\n          if(node.isFinish !== true && startNodeDistance !== null){\n            let prevNode = nodesInShortestPathOrder[i - 1];\n              if(prevNode !== undefined && prevNode !== null){\n                const currentNode = nodesInShortestPathOrder[i];\n                if(currentNode.col > prevNode.col){\n                  this.setHTMLClass(`node-${node.row}-${node.col}`, 'node node-shortest-path-right');\n                  // moved a column to right\n                }else if(currentNode.col < prevNode.col){\n                  this.setHTMLClass(`node-${node.row}-${node.col}`, 'node node-shortest-path-left');\n                  // moved a column to left\n                }else if(currentNode.row > prevNode.row){\n                  this.setHTMLClass(`node-${node.row}-${node.col}`, 'node node-shortest-path-down');\n                  // moved a row down\n                }else if(currentNode.row < prevNode.row){\n                  this.setHTMLClass(`node-${node.row}-${node.col}`, 'node node-shortest-path-up');\n                  // moved a row up\n                }\n              }\n            }\n          }\n        }, 50 * i);\n    }\n\n    setTimeout(() => {\n      this.setState({isAnimationRunning: false});\n    }, 1000)\n  }\n\n  ///////////////////////////////////////\n  // FUNCTION: CLEAR GRID\n  ///////////////////////////////////////\n  clearGrid = () => {\n    const { grid } = this.state;\n    const algorithmTime = document.getElementById('algorithm-time');\n    if(algorithmTime){\n      algorithmTime.innerHTML = '';\n    }\n\n    for(let i  = 0; i < grid.length; i++){\n      for(let j = 0; j < grid[0].length; j++){\n        const node = grid[i][j];\n        const nodeHTML = document.getElementById(`node-${node.row}-${node.col}`);\n        node.isVisited = false;\n        node.isWall = false;\n        node.distance = Infinity;\n        node.previousNode = null;\n        if(nodeHTML){\n          if(node.isStart === true){\n            nodeHTML.className = 'node node-img-start';\n          }else if(grid[i][j].isFinish === true){\n            nodeHTML.className = 'node node-img-finish';\n          }else if(grid[i][j].isWall === true){\n            nodeHTML.className = 'node node-wall';\n          }else{\n            nodeHTML.className = 'node';\n          }\n        }\n      }\n    }\n  }\n\n  changeAnimationSpeed = () => {\n    const animationSpeed = document.getElementById('change-speed');\n    const changeSpeedIcon = document.getElementById('change-speed-icon'); \n    if(animationSpeed && changeSpeedIcon){ \n      if(animationSpeed.innerHTML === 'Slow' || animationSpeed.innerHTML === 'Change Speed'){\n        animationSpeed.innerHTML = 'Medium';\n        changeSpeedIcon.classList.add('fa-fast-forward')\n        this.setState({animationSpeed: 40});\n      }else if(animationSpeed.innerHTML === 'Medium'){\n        animationSpeed.innerHTML = 'Fast';\n        changeSpeedIcon.classList.add('fa-fast-backward')\n        changeSpeedIcon.classList.remove('fa-fast-forward')\n        this.setState({animationSpeed: 10});\n      }else if(animationSpeed.innerHTML === 'Fast'){\n        animationSpeed.innerHTML = 'Slow';\n        changeSpeedIcon.classList.remove('fa-fast-backward')\n        changeSpeedIcon.classList.add('fa-fast-forward')\n        this.setState({animationSpeed: 90});\n      }\n    }\n  };\n\n  ///////////////////////////////////////\n  // FUNCTION: VISUALIZE DIJKSTRA\n  ///////////////////////////////////////\n  visualizeDijkstra = () => {\n    const { grid, isAnimationRunning } = this.state;\n    if(isAnimationRunning === false){\n      this.setState({isAnimationRunning: true});\n      for(let i  = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length; j++){\n          const nodeHTML = document.getElementById(`node-${i}-${j}`);\n          if(nodeHTML){\n            if(grid[i][j].isStart === true){\n              nodeHTML.className = 'node node-img-start';\n            }else if(grid[i][j].isFinish === true){\n              nodeHTML.className = 'node node-img-finish';\n            }else if(grid[i][j].isWall === true){\n              nodeHTML.className = 'node node-wall';\n            }else{\n              nodeHTML.className = 'node';\n            }\n            grid[i][j].distance = Infinity;\n            grid[i][j].isVisited = false;\n            grid[i][j].previousNode = null;\n        }\n          }\n        }    \n\n      const timeStart = performance.now();\n      const startNode = grid[START_NODE_ROW][START_NODE_COL];\n      const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n      const returnDijkstra = dijkstra(grid, startNode, finishNode);\n      if(returnDijkstra){\n        const startNodeDistance = returnDijkstra.startNodeDistance;\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n        this.animateDijkstra(returnDijkstra.visitedNodesInOrder, nodesInShortestPathOrder, startNodeDistance);\n        const timeEnd = performance.now();\n        let string = \"\"\n        if(startNodeDistance === null){\n          string = \"and can't reach the target node, it's enclosed into a box!\"\n        }else{\n          string = `and took ${startNodeDistance} steps.`\n        }\n        const algorithmTime = document.getElementById('algorithm-time');  \n        if(algorithmTime){\n          algorithmTime.innerHTML = `Dijkstra's algorithm took ${(timeEnd - timeStart) / 1000} seconds to execute ${string}`;\n        }\n      }\n    }\n  }\n  \n\n  visualizeAstar = () => {\n    const { grid } = this.state;\n    for(let i  = 0; i < grid.length; i++){\n      for(let j = 0; j < grid[i].length; j++){\n        if(grid[i][j].isStart === true){\n          this.setHTMLClass(`node-${i}-${j}`, 'node node-img-start');\n        }else if(grid[i][j].isFinish === true){\n          this.setHTMLClass(`node-${i}-${j}`, 'node node-img-finish');\n        }else if(grid[i][j].isWall === true){\n          this.setHTMLClass(`node-${i}-${j}`, 'node node-wall');\n        }else{\n          this.setHTMLClass(`node-${i}-${j}`, 'node');\n        }\n        grid[i][j].distance = Infinity;\n        grid[i][j].isVisited = false;\n        //grid[i][j].isWall = false;\n        grid[i][j].previousNode = null;\n        }\n      }\n      /*\n    const timeStart = performance.now();\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const returnAstar = astar(grid, startNode, finishNode, 8);\n    //const startNodeDistance = returnAstar.startNodeDistance;\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    //this.animateDijkstra(returnAstar.visitedNodesInOrder, nodesInShortestPathOrder);\n    const timeEnd = performance.now();\n    */\n  }\n\n  render() {\n    const { grid } = this.state;\n    return (\n      <>\n        <Navbar changeAnimationSpeed={this.changeAnimationSpeed} generateScatterRandom={this.generateScatterRandom} visualizeAstar={this.visualizeAstar} generateRandomMaze={this.generateRandomMaze} clearGrid={this.clearGrid} visualizeDijkstra={this.visualizeDijkstra}/>\n        <div className=\"grid\">\n          {grid.map((row : any, rowIdx : number) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node : any, nodeIdx : number) => {\n                  const {row, col, isFinish, isStart, isWall} = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      onMouseDown={(row : number, col : number) => this.handleMouseRightDown(row, col)}\n                      onMouseEnter={(row : number, col : number) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                      row={row}></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n        \n        <TextArea secondaryText=\"Made by Neel Bansal\" text=\"Dijkstra's algorithm is an algorithm for finding the shortest paths between nodes in a graph, it sets every nodes distance to Infinity, and then the main node searches up, down, left and right. It continues this throughout the execution. \"/>\n        <div className='note-wrapper'>   \n          <Note node=\"true\" title='Unvisited Node' iconClass='node' text='This is not the start, finish, or wall node; it is a node that has not yet been visited. This is normally how the probram begins, with none of the nodes visited.'/>\n          <Note node=\"true\" title='Start / Source Node' iconClass='node-start' text='The start node is where the program begins its search; it will make that the primary node and work its way to the solution from there. This can be changed by pressing the \"s\" key over a node.'/>\n          <Note node=\"true\" title='Finish / Target Node' iconClass='node-finish' text='The finish node is the one that the program is looking for and will attempt to locate. It will give an error if it is unable to locate it. This can be changed by pressing the \"f\" key over a node.'/>\n          <Note node=\"true\" title='Wall Node' iconClass='node-wall' text='The wall nodes prevent the program from searching in that area; they can also be used to demonstrate how roads can prevent cars from entering a specific location.'/>\n          <Note node=\"true\" title='Visited Node' iconClass='node-visited' text='The visited node is the node that the program has visited. It is the node that the program is currently on.'/>\n          <Note node=\"true\" title='Shortest Path Node' iconClass='node-shortest-path-right' text=\"The node that the program has visited is the visited node. It's the node where the software looked for the target node previously.\"/>\n          <Note title=\"Grid\" text='The grid is the area that the program searches. It is the area that the program searches for the target node.'>\n            <div style={{display: 'left', padding: '50px 0px 0px 100px'}}>\n              <div style={{width: '25px', height: '25px', outline: '1px solid rgb(175, 216, 248)', display: 'table-cell', margin: '0% 45%', justifyContent: 'center', alignItems: 'center', verticalAlign: 'text-bottom'}} className='node'></div>\n              <div style={{width: '25px', height: '25px', outline: '1px solid rgb(175, 216, 248)', display: 'table-cell', margin: '0% 45%', justifyContent: 'center', alignItems: 'center', verticalAlign: 'text-bottom'}} className='node'></div>\n              <div style={{width: '25px', height: '25px', outline: '1px solid rgb(175, 216, 248)', display: 'table-cell', margin: '0% 45%', justifyContent: 'center', alignItems: 'center', verticalAlign: 'text-bottom'}} className='node'></div>\n            </div>\n\n          <div style={{display: 'left', padding: '0px 10px 0px 100px'}}>\n            <div style={{width: '25px', height: '25px', outline: '1px solid rgb(175, 216, 248)', display: 'table-cell', margin: '0% 45%', justifyContent: 'center', alignItems: 'center', verticalAlign: 'text-bottom'}} className='node'></div>\n            <div style={{width: '25px', height: '25px', outline: '1px solid rgb(175, 216, 248)', display: 'table-cell', margin: '0% 45%', justifyContent: 'center', alignItems: 'center', verticalAlign: 'text-bottom'}} className='node'></div>\n            <div style={{width: '25px', height: '25px', outline: '1px solid rgb(175, 216, 248)', display: 'table-cell', margin: '0% 45%', justifyContent: 'center', alignItems: 'center', verticalAlign: 'text-bottom'}} className='node'></div>\n          </div>\n          <div style={{display: 'left', padding: '0px 10px 30px 100px'}}>\n            <div style={{width: '25px', height: '25px', outline: '1px solid rgb(175, 216, 248)', display: 'table-cell', margin: '0% 45%', justifyContent: 'center', alignItems: 'center', verticalAlign: 'text-bottom'}} className='node'></div>\n            <div style={{width: '25px', height: '25px', outline: '1px solid rgb(175, 216, 248)', display: 'table-cell', margin: '0% 45%', justifyContent: 'center', alignItems: 'center', verticalAlign: 'text-bottom'}} className='node'></div>\n            <div style={{width: '25px', height: '25px', outline: '1px solid rgb(175, 216, 248)', display: 'table-cell', margin: '0% 45%', justifyContent: 'center', alignItems: 'center', verticalAlign: 'text-bottom'}} className='node'></div>\n          </div> \n          </Note>\n        </div>\n        <br></br>\n        </>\n    );\n  }\n\n\n  ///////////////////////////////////////\n  // FUNCTION: GENERATE SCATTER RANDOM\n  ///////////////////////////////////////\n  \n  generateScatterRandom = () =>{\n    const { grid, isAnimationRunning } = this.state;\n    if(!isAnimationRunning){\n      const walledMaze = scatterRandom(grid)\n      this.setState({\n        grid: walledMaze\n      })\n  }\n  }\n  \n  generateRandomMaze = () => {\n    const { grid } = this.state;\n    newMaze(grid);\n    /*console.log(walledMaze);\n    for(let i = 0; i < ROWS; i++){\n      for(let j = 0; j < COLS; j++){\n        if(walledMaze[0][i][j] === 1){\n          grid[i][j].isWall = true;\n        }else{\n          grid[i][j].isWall = false;\n        }\n        grid[i][j].isWall = false;\n        grid[i][j].isVisited = false;\n        grid[i][j].distance = Infinity;\n        grid[i][j].previousNode = null;\n      }\n    }*/\n      }\n}\n\n///////////////////////////////////////\n// CLASS: NAVBAR\n///////////////////////////////////////\n\ninterface NavbarProps {\n  clearGrid: any; \n  visualizeDijkstra : any;\n  generateRandomMaze : any;\n  visualizeAstar : any;\n  generateScatterRandom  : any;\n  changeAnimationSpeed : any;\n} \n\nclass Navbar extends Component <NavbarProps> {\n  render() {\n    let clearGrid = this.props.clearGrid;\n    let visualizeDijkstra = this.props.visualizeDijkstra; \n    let generateRandomMaze = this.props.generateRandomMaze;    \n    //let visualizeAstar = this.props.visualizeAstar;\n    let generateScatterRandom = this.props.generateScatterRandom;\n    let changeAnimationSpeed = this.props.changeAnimationSpeed;\n    return (\n      <div className=\"navbar-wrapper\">\n      <nav className=\"navbar navbar-dark navbar-expand justify-content-center\">\n    <div className=\"container\">\n        <ul className=\"navbar-nav nav-justified w-100 text-center mt-1\">\n        <li className=\"nav-item\">\n                <a href=\"#!\" className=\"nav-link d-flex flex-column\" data-toggle=\"collapse\" onClick={() => visualizeDijkstra()}>\n                    <span className=\"fa fa-map-marker fa-lg\"></span>\n                    <span className=\"d-none d-sm-inline mt-1\">Dijkstra's Algorithm</span>\n                </a>\n            </li> \n            <li className=\"nav-item\">\n                <a href=\"#!\" className=\"nav-link d-flex flex-column\" data-toggle=\"collapse\" onClick={() => generateScatterRandom()}>\n                    <span className=\"fa fa-question fa-lg\"></span>\n                    <span className=\"d-none d-sm-inline mt-1\">Generate Scatter</span>\n                </a>\n            </li>\n            <li className=\"nav-item\">\n                <a href=\"#!\" className=\"nav-link d-flex flex-column\" data-toggle=\"collapse\" onClick={() => changeAnimationSpeed()}>\n                    <span id=\"change-speed-icon\" className=\"fa fa-fast-forward fa-lg\"></span>\n                    <span id=\"change-speed\" className=\"d-none d-sm-inline mt-1\">Change Speed</span>\n                </a>\n            </li>\n            <li className=\"nav-item\">\n                <a href=\"#!\" className=\"nav-link d-flex flex-column\" data-toggle=\"collapse\" onClick={() => generateRandomMaze()}>\n                    <span className=\"fa fa-microchip fa-lg\"></span>\n                    <span className=\"d-none d-sm-inline mt-1\">New Maze (W.I.P)</span>\n                </a>\n            </li> \n            <li className=\"nav-item\">\n                <a href=\"#!\" className=\"nav-link d-flex flex-column\" data-toggle=\"collapse\" onClick={() => clearGrid()}>\n                    <span className=\"fa fa-th fa-lg\"></span>\n                    <span className=\"d-none d-sm-inline mt-1\">Clear Grid</span>\n                </a>\n            </li>\n        </ul>\n    </div>\n</nav>  \n</div>\n      \n    );\n  }\n}\ninterface NoteProps{\n  title?: string;\n  text?: string;\n  iconClass?: string;\n  node?: string;\n  children?: any;\n}\n\nclass Note extends Component <NoteProps>{\n  \n  render() {\n    const title = this.props.title;\n    const text = this.props.text;\n    const iconClass = this.props.iconClass;\n    const node = this.props.node;\n    let nodeDiv;\n    if(node){\n      nodeDiv = <div style={{width: '25px', height: '25px', outline: '1px solid rgb(175, 216, 248)', display: 'flex', margin: '15% 45%', justifyContent: 'center', alignItems: 'center', verticalAlign: 'text-bottom'}} className={iconClass}></div>\n    }else{\n      nodeDiv = null;\n    }\n\n    return (\n      <div className=\"note-wrapper\">\n      <div className=\"card\" style={{width: \"18rem\"}}>\n        {this.props.children}\n        {nodeDiv}\n        <div className=\"card-body\">\n          <h5 className=\"card-title\">{title}</h5>\n          <p className=\"card-text\">{text}</p>\n        </div>\n      </div>\n      </div>\n    );\n    }\n}\n\n///////////////////////////////////////\n// CLASS: TEXTAREA\n///////////////////////////////////////\n\ninterface TextAreaProps {\n  text: string;\n  secondaryText?: string;\n}\n\nclass TextArea extends Component <TextAreaProps> {\n  render() {\n    const text = this.props.text\n    const secondaryText = this.props.secondaryText\n    return (\n      <div className=\"note-wrapper\">\n        <div className=\"note\">\n          <p>{text}</p>\n          <p id=\"algorithm-time\"></p>\n          <h6 style={{fontWeight: 'normal'}}>{secondaryText}</h6>\n          </div>\n      </div>\n    );\n  }\n}\n\n///////////////////////////////////////\n// FUNCTION: GET INITIAL GRID\n///////////////////////////////////////\n\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row < ROWS; row++) {\n    const currentRow = [];\n    for (let col = 0; col < COLS; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\n///////////////////////////////////////\n// FUNCTION: CREATE NODE\n///////////////////////////////////////\nconst createNode = (col : number, row : number) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\nconst getNewGridWithWallToggled = (grid: Array<any>, row : number, col : number) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n","///////////////////////////////////////\n// IMPORTING MODULES\n///////////////////////////////////////\n\nimport React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\n\n///////////////////////////////////////\n// FUNCTION: APP\n///////////////////////////////////////\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\n///////////////////////////////////////\n// EXPORTING: APP\n///////////////////////////////////////\n\nexport default App;\n","///////////////////////////////////////\n// IMPORTING MODULES\n///////////////////////////////////////\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport './index.css';\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\n///////////////////////////////////////\n// RENDERING REACTDOM APP\n///////////////////////////////////////\n\nReactDOM.render(<App />, document.getElementById('root'));"],"sourceRoot":""}