{"ast":null,"code":"const astar = function (grid, start, goal, heuristic) {\n  //This contains the distances from the start node to all other nodes\n  var distances = []; //Initializing with a distance of \"Infinity\"\n\n  for (var i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      //distances[i][j] = Infinity;\n      console.log(grid[i][j]);\n\n      if (grid[i][j].isStart === true) {\n        distances[i][j] = 0;\n        console.log(distances);\n      }\n    }\n  }\n\n  for (var i = 0; i < grid.length; i++) distances[i] = Number.MAX_VALUE; //The distance from the start node to itself is of course 0\n\n\n  distances[start] = 0; //This contains the priorities with which to visit the nodes, calculated using the heuristic.\n\n  var priorities = []; //Initializing with a priority of \"Infinity\"\n\n  for (var i = 0; i < grid.length; i++) priorities[i] = Number.MAX_VALUE; //start node has a priority equal to straight line distance to goal. It will be the first to be expanded.\n\n\n  priorities[start] = heuristic[start][goal]; //This contains whether a node was already visited\n\n  var visited = []; //While there are nodes left to visit...\n\n  while (true) {\n    // ... find the node with the currently lowest priority...\n    var lowestPriority = Number.MAX_VALUE;\n    var lowestPriorityIndex = -1;\n\n    for (var i = 0; i < priorities.length; i++) {\n      //... by going through all nodes that haven't been visited yet\n      if (priorities[i] < lowestPriority && !visited[i]) {\n        lowestPriority = priorities[i];\n        lowestPriorityIndex = i;\n      }\n    }\n\n    if (lowestPriorityIndex === -1) {\n      // There was no node not yet visited --> Node not found\n      return -1;\n    } else if (lowestPriorityIndex === goal) {\n      // Goal node found\n      // console.log(\"Goal node found!\");\n      return distances[lowestPriorityIndex];\n    } // console.log(\"Visiting node \" + lowestPriorityIndex + \" with currently lowest priority of \" + lowestPriority);\n    //...then, for all neighboring nodes that haven't been visited yet....\n\n\n    for (var i = 0; i < grid[lowestPriorityIndex].length; i++) {\n      if (grid[lowestPriorityIndex][i] !== 0 && !visited[i]) {\n        //...if the path over this edge is shorter...\n        if (distances[lowestPriorityIndex] + grid[lowestPriorityIndex][i] < distances[i]) {\n          //...save this path as new shortest path\n          distances[i] = distances[lowestPriorityIndex] + grid[lowestPriorityIndex][i]; //...and set the priority with which we should continue with this node\n\n          priorities[i] = distances[i] + heuristic[i][goal]; // console.log(\"Updating distance of node \" + i + \" to \" + distances[i] + \" and priority to \" + priorities[i]);\n        }\n      }\n    } // Lastly, note that we are finished with this node.\n\n\n    visited[lowestPriorityIndex] = true; //console.log(\"Visited nodes: \" + visited);\n    //console.log(\"Currently lowest distances: \" + distances);\n  }\n};\n\nexport default astar;","map":{"version":3,"sources":["C:\\Users\\GAMER\\Desktop\\Pathfinding-Visualizer\\src\\algorithms\\astar.js"],"names":["astar","grid","start","goal","heuristic","distances","i","length","j","console","log","isStart","Number","MAX_VALUE","priorities","visited","lowestPriority","lowestPriorityIndex"],"mappings":"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","sourcesContent":["const astar = function (grid, start, goal, heuristic) {\r\n\r\n    //This contains the distances from the start node to all other nodes\r\n    var distances = [];\r\n    //Initializing with a distance of \"Infinity\"\r\n    for (var i = 0; i < grid.length; i++) {\r\n        for(let j = 0; j < grid[i].length; j++){\r\n            //distances[i][j] = Infinity;\r\n            console.log(grid[i][j])\r\n            if(grid[i][j].isStart === true){\r\n                distances[i][j] = 0;\r\n                console.log(distances)\r\n            }\r\n        }\r\n    }\r\n    for (var i = 0; i < grid.length; i++) distances[i] = Number.MAX_VALUE;\r\n    //The distance from the start node to itself is of course 0\r\n    distances[start] = 0;\r\n\r\n    //This contains the priorities with which to visit the nodes, calculated using the heuristic.\r\n    var priorities = [];\r\n    //Initializing with a priority of \"Infinity\"\r\n    for (var i = 0; i < grid.length; i++) priorities[i] = Number.MAX_VALUE;\r\n    //start node has a priority equal to straight line distance to goal. It will be the first to be expanded.\r\n    priorities[start] = heuristic[start][goal];\r\n\r\n    //This contains whether a node was already visited\r\n    var visited = [];\r\n\r\n    //While there are nodes left to visit...\r\n    while (true) {\r\n\r\n        // ... find the node with the currently lowest priority...\r\n        var lowestPriority = Number.MAX_VALUE;\r\n        var lowestPriorityIndex = -1;\r\n        for (var i = 0; i < priorities.length; i++) {\r\n            //... by going through all nodes that haven't been visited yet\r\n            if (priorities[i] < lowestPriority && !visited[i]) {\r\n                lowestPriority = priorities[i];\r\n                lowestPriorityIndex = i;\r\n            }\r\n        }\r\n\r\n        if (lowestPriorityIndex === -1) {\r\n            // There was no node not yet visited --> Node not found\r\n            return -1;\r\n        } else if (lowestPriorityIndex === goal) {\r\n            // Goal node found\r\n            // console.log(\"Goal node found!\");\r\n            return distances[lowestPriorityIndex];\r\n        }\r\n\r\n        // console.log(\"Visiting node \" + lowestPriorityIndex + \" with currently lowest priority of \" + lowestPriority);\r\n\r\n        //...then, for all neighboring nodes that haven't been visited yet....\r\n        for (var i = 0; i < grid[lowestPriorityIndex].length; i++) {\r\n            if (grid[lowestPriorityIndex][i] !== 0 && !visited[i]) {\r\n                //...if the path over this edge is shorter...\r\n                if (distances[lowestPriorityIndex] + grid[lowestPriorityIndex][i] < distances[i]) {\r\n                    //...save this path as new shortest path\r\n                    distances[i] = distances[lowestPriorityIndex] + grid[lowestPriorityIndex][i];\r\n                    //...and set the priority with which we should continue with this node\r\n                    priorities[i] = distances[i] + heuristic[i][goal];\r\n                    // console.log(\"Updating distance of node \" + i + \" to \" + distances[i] + \" and priority to \" + priorities[i]);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Lastly, note that we are finished with this node.\r\n        visited[lowestPriorityIndex] = true;\r\n        //console.log(\"Visited nodes: \" + visited);\r\n        //console.log(\"Currently lowest distances: \" + distances);\r\n\r\n    }\r\n};\r\n\r\nexport default astar;"]},"metadata":{},"sourceType":"module"}